// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_REPORT_BLOATY_REPORT_H_
#define FLATBUFFERS_GENERATED_REPORT_BLOATY_REPORT_H_

#include "flatbuffers/flatbuffers.h"

namespace bloaty_report {

struct SizeInfo;

struct Symbol;
struct SymbolBuilder;

struct CompileUnit;
struct CompileUnitBuilder;

struct Report;
struct ReportBuilder;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) SizeInfo FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t fileActual_;
  uint32_t vmActual_;

 public:
  SizeInfo() {
    memset(static_cast<void *>(this), 0, sizeof(SizeInfo));
  }
  SizeInfo(uint32_t _fileActual, uint32_t _vmActual)
      : fileActual_(flatbuffers::EndianScalar(_fileActual)),
        vmActual_(flatbuffers::EndianScalar(_vmActual)) {
  }
  uint32_t fileActual() const {
    return flatbuffers::EndianScalar(fileActual_);
  }
  uint32_t vmActual() const {
    return flatbuffers::EndianScalar(vmActual_);
  }
};
FLATBUFFERS_STRUCT_END(SizeInfo, 8);

struct Symbol FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SymbolBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SIZES = 4,
    VT_NAME = 6
  };
  const bloaty_report::SizeInfo *sizes() const {
    return GetStruct<const bloaty_report::SizeInfo *>(VT_SIZES);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<bloaty_report::SizeInfo>(verifier, VT_SIZES) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct SymbolBuilder {
  typedef Symbol Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sizes(const bloaty_report::SizeInfo *sizes) {
    fbb_.AddStruct(Symbol::VT_SIZES, sizes);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Symbol::VT_NAME, name);
  }
  explicit SymbolBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Symbol> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Symbol>(end);
    return o;
  }
};

inline flatbuffers::Offset<Symbol> CreateSymbol(
    flatbuffers::FlatBufferBuilder &_fbb,
    const bloaty_report::SizeInfo *sizes = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  SymbolBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_sizes(sizes);
  return builder_.Finish();
}

inline flatbuffers::Offset<Symbol> CreateSymbolDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const bloaty_report::SizeInfo *sizes = 0,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return bloaty_report::CreateSymbol(
      _fbb,
      sizes,
      name__);
}

struct CompileUnit FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CompileUnitBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SIZES = 4,
    VT_SYMBOLS = 6,
    VT_NAME = 8
  };
  const bloaty_report::SizeInfo *sizes() const {
    return GetStruct<const bloaty_report::SizeInfo *>(VT_SIZES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<bloaty_report::Symbol>> *symbols() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<bloaty_report::Symbol>> *>(VT_SYMBOLS);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<bloaty_report::SizeInfo>(verifier, VT_SIZES) &&
           VerifyOffset(verifier, VT_SYMBOLS) &&
           verifier.VerifyVector(symbols()) &&
           verifier.VerifyVectorOfTables(symbols()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct CompileUnitBuilder {
  typedef CompileUnit Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_sizes(const bloaty_report::SizeInfo *sizes) {
    fbb_.AddStruct(CompileUnit::VT_SIZES, sizes);
  }
  void add_symbols(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<bloaty_report::Symbol>>> symbols) {
    fbb_.AddOffset(CompileUnit::VT_SYMBOLS, symbols);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(CompileUnit::VT_NAME, name);
  }
  explicit CompileUnitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CompileUnit> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CompileUnit>(end);
    return o;
  }
};

inline flatbuffers::Offset<CompileUnit> CreateCompileUnit(
    flatbuffers::FlatBufferBuilder &_fbb,
    const bloaty_report::SizeInfo *sizes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<bloaty_report::Symbol>>> symbols = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  CompileUnitBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_symbols(symbols);
  builder_.add_sizes(sizes);
  return builder_.Finish();
}

inline flatbuffers::Offset<CompileUnit> CreateCompileUnitDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const bloaty_report::SizeInfo *sizes = 0,
    const std::vector<flatbuffers::Offset<bloaty_report::Symbol>> *symbols = nullptr,
    const char *name = nullptr) {
  auto symbols__ = symbols ? _fbb.CreateVector<flatbuffers::Offset<bloaty_report::Symbol>>(*symbols) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return bloaty_report::CreateCompileUnit(
      _fbb,
      sizes,
      symbols__,
      name__);
}

struct Report FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReportBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COMPILEUNITS = 4,
    VT_FILETOTAL = 6,
    VT_VMTOTAL = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<bloaty_report::CompileUnit>> *compileUnits() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<bloaty_report::CompileUnit>> *>(VT_COMPILEUNITS);
  }
  uint32_t fileTotal() const {
    return GetField<uint32_t>(VT_FILETOTAL, 0);
  }
  uint32_t vmTotal() const {
    return GetField<uint32_t>(VT_VMTOTAL, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_COMPILEUNITS) &&
           verifier.VerifyVector(compileUnits()) &&
           verifier.VerifyVectorOfTables(compileUnits()) &&
           VerifyField<uint32_t>(verifier, VT_FILETOTAL) &&
           VerifyField<uint32_t>(verifier, VT_VMTOTAL) &&
           verifier.EndTable();
  }
};

struct ReportBuilder {
  typedef Report Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_compileUnits(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<bloaty_report::CompileUnit>>> compileUnits) {
    fbb_.AddOffset(Report::VT_COMPILEUNITS, compileUnits);
  }
  void add_fileTotal(uint32_t fileTotal) {
    fbb_.AddElement<uint32_t>(Report::VT_FILETOTAL, fileTotal, 0);
  }
  void add_vmTotal(uint32_t vmTotal) {
    fbb_.AddElement<uint32_t>(Report::VT_VMTOTAL, vmTotal, 0);
  }
  explicit ReportBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Report> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Report>(end);
    return o;
  }
};

inline flatbuffers::Offset<Report> CreateReport(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<bloaty_report::CompileUnit>>> compileUnits = 0,
    uint32_t fileTotal = 0,
    uint32_t vmTotal = 0) {
  ReportBuilder builder_(_fbb);
  builder_.add_vmTotal(vmTotal);
  builder_.add_fileTotal(fileTotal);
  builder_.add_compileUnits(compileUnits);
  return builder_.Finish();
}

inline flatbuffers::Offset<Report> CreateReportDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<bloaty_report::CompileUnit>> *compileUnits = nullptr,
    uint32_t fileTotal = 0,
    uint32_t vmTotal = 0) {
  auto compileUnits__ = compileUnits ? _fbb.CreateVector<flatbuffers::Offset<bloaty_report::CompileUnit>>(*compileUnits) : 0;
  return bloaty_report::CreateReport(
      _fbb,
      compileUnits__,
      fileTotal,
      vmTotal);
}

inline const bloaty_report::Report *GetReport(const void *buf) {
  return flatbuffers::GetRoot<bloaty_report::Report>(buf);
}

inline const bloaty_report::Report *GetSizePrefixedReport(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<bloaty_report::Report>(buf);
}

inline bool VerifyReportBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<bloaty_report::Report>(nullptr);
}

inline bool VerifySizePrefixedReportBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<bloaty_report::Report>(nullptr);
}

inline void FinishReportBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<bloaty_report::Report> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedReportBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<bloaty_report::Report> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace bloaty_report

#endif  // FLATBUFFERS_GENERATED_REPORT_BLOATY_REPORT_H_
